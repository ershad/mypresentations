\documentclass[14pt]{beamer}

\usetheme{CambridgeUS}
\usepackage{amsmath}
\usepackage{courier}
\usepackage{enumerate}
\setbeamertemplate{itemize items}[circle]
\usepackage{graphicx}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage[normalem]{ulem}

\mode<presentation>
{
\setbeamertemplate{footline}
{\rightline{\insertframenumber/\inserttotalframenumber}}
}

\title{OpenMP Fundamentals}
\author{\textbf{Raghesh A}}
\date

\begin{document}

% slide
\begin{frame}
\titlepage
\end{frame}

% slide
\begin{frame}{Introduction}
\begin{itemize}
\item Standard defining APIs for multi-threaded, shared memory architectures
\item API contains
  \begin{itemize}
  \item Compiler directives
  \item Runtime library routines
  \item Environment variables
  \end{itemize}
\item Major implementations - libgomp, MPC
\end{itemize}
\end{frame}

% slide
\begin{frame}{OpenMP Programming Model}
\begin{itemize}
\item Shared memory
\item Thread based parallelism
\item Explicit parallelism
\item Fork - Join model
\item IO - No consistency guaranteed
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Hello world...}
\begin{Verbatim}
#include <omp.h>
#include <stdio.h>
int main() {        
  int iam =0, np = 1;
#pragma omp parallel private(iam, np)
  {
    np = omp_get_num_threads();
    iam = omp_get_thread_num();
    printf("Hello from thread %d out of %d \n", iam, np);
  }
}
\end{Verbatim}
\end{frame}

% slide
\begin{frame}[fragile]
\frametitle{Hello world contd...}
\begin{block}
{To build: gcc -fopenmp hello.c}
\end{block}
\end{frame}

% slide
\begin{frame}[fragile]{Constructs for parallelism}
General synatax:
\begin{Verbatim}
#pragma omp construct [clause [clause]...]
\end{Verbatim}
Constructs can be:
\begin{itemize}
\item parallel
\item parallel for
\item parallel sections
\item single
\end{itemize}
\end{frame}

% slide 
\begin{frame}[fragile]{The parallel region}
Fundamental construct that initiates parallel execution:
\begin{Verbatim}
#pragma omp parallel [clause [clause]...]
\end{Verbatim}
Clauses can be:
\begin{itemize}
\item private
\item shared
\item firstprivate
\item lastprivate
\item reduction
\end{itemize}
\end{frame}

% slide
\begin{frame}[fragile]{shared clause}
\$ export OMP\_NUM\_THREADS=8
\begin{Verbatim}
  int b = 0;
#pragma omp parallel shared(b)
  {
    b++;
  }
  printf("%d\n", b);
\end{Verbatim}
Output: b is incremented by all threads created
\end{frame}

% slide
\begin{frame}[fragile]{private clause}
\$ export OMP\_NUM\_THREADS=8
\begin{Verbatim}
#include <omp.h>
#include <stdio.h>
int main() {
  int b = 20, tid = 0;
#pragma omp parallel private(b, tid)
  {
    b++;
    tid = omp_get_thread_num();
    printf("Thread %d: b = %d\n", tid, b);
  }
  printf("%d\n", b);
}
\end{Verbatim}
Output: Each thread has a copy of variable b. Initial value of b is undefined.
\end{frame}

% slide
\begin{frame}[fragile]{firstprivate clause}
\$ export OMP\_NUM\_THREADS=8
\begin{Verbatim}
#include <omp.h>
#include <stdio.h>

int main() {
  int b = 20, tid = 0;
#pragma omp parallel private(tid) firstprivate(b)
  {
    b++;
    tid = omp_get_thread_num();
    printf("Thread %d: b = %d\n", tid, b);
  }
  printf("b = %d\n", b);
}
\end{Verbatim}
\end{frame}

% slide
\begin{frame}[fragile]{parallel for}
\begin{Verbatim}
#include <omp.h>
#include <stdio.h>

#define SIZE 20
int main() {        
  int a[SIZE], b[SIZE], c[SIZE];
  int i, tid;

  for(i = 0; i < SIZE; i++) {
    a[i] = i;
    b[i] = 2 * i;
  }

#pragma omp parallel  shared(a), private(i, tid)
  {
#pragma omp for
    for(i = 0; i < SIZE; i++) {
      c[i] = a[i] + b[i];
      tid = omp_get_thread_num();
      printf("Thread %d, i = %d\n", tid, i);
    }
  }

  for(i = 0; i < SIZE; i++)
    printf("%d\n", c[i]);
}
\end{Verbatim}
Observe the parallelism. work is distributed among threads.
\end{frame}

% slide
\begin{frame}[fragile]{parallel for with different chunk size}
0
\end{frame}

% slide
\begin{frame}[fragile]{parallel for with different schedule size}
0
\end{frame}

% slide
\begin{frame}[fragile]{lastprivate clause}
will not work with parallel consturct, works with parallel for
\end{frame}

% slide
\begin{frame}[fragile]{reduction clause}
1
\end{frame}

% slide
\begin{frame}[fragile]{Example: Dot product in Pthreads, MPI and OPenMP}
1
\end{frame}

% slide
\begin{frame}{Constructs for synchronization}
\begin{itemize}
\item 1
\end{itemize}
\end{frame}

% slide
\begin{frame}{Constructs for synchronization}
\begin{itemize}
\item 1
\end{itemize}
\end{frame}

% slide
\begin{frame}{Restrictions on synchronization over parallelism}
\begin{itemize}
\item Restriction on the position of omp barrier inside omp parallel
\item Other restrictions?
\end{itemize}
\end{frame}

% slide
\begin{frame}{Relative costs of each of the parallel constructs}
\begin{itemize}
\item cost of barrier
\item cost of one task creation
\item other costs?
\end{itemize}
\end{frame}

% slide
\begin{frame}{An example(no synchronization) - Mergesort}
\begin{itemize}
\item Nice and easy way to understand concepts
\item Each recursive calls works on different data sets
\item So easy to parallelize
\end{itemize}
\end{frame}

% slide
\begin{frame}{An example(with synchronization)}
\begin{itemize}
\item 1
\end{itemize}
\end{frame}

% slide
\begin{frame}{OpenMP in Polly}
\begin{itemize}
\item 1
\end{itemize}
\end{frame}


% slide
\begin{frame}{References}
\begin{itemize}
\item https://computing.llnl.gov/tutorials/openMP/
\item Parallel Programming with OpenMP: Science and Technology Support Group, High Performance Computing, Ohio Supercomputer Center
\end{itemize}
\end{frame}


\end{document}
